# PLCRVoting.sol
# each poll is an instance of a vote on a singal (ERC721 token in the TCR)
type Poll @entity {
    id: ID!
    creator: Bytes!
    commitEndDate: BigInt!
    revealEndDate: BigInt!
    voteQuorum: BigInt!
    votesFor: BigInt!
    votesAgainst: BigInt!
    didCommit: [Bytes!]!                            # if an address is in here, they did commit a vote
    didReveal: [Bytes!]!                           # if an address is in here, they did reveal their vote
    votes: [Vote!]! @derivedFrom(field: "pollID")
    totalTokens: BigInt!

    # TODO - add dllMap?
}

type Vote @entity {
    id: ID!                             # concatenation of POLLID-ETHADDRESS
    pollID: BigInt!                     # for relational connections
    user: Bytes!                        # for relational connections
    numTokens: BigInt!
    votedFor: Boolean                   # true means voted for, false agaisnt, null unknown
}

# Registry.sol
type Listing @entity {
    id: ID!
    owner: Bytes!
    whitelist: Boolean!
    applicationExpiry: BigInt!
    unstakedDeposit: BigInt!
    data: String!                       # extra data (think ipfs hashes)
    challengeID: BigInt
    deleted: Boolean!                   # when true, listing has been deleted from the smart contract


    # TODO - relate challenges, prob an array , related to the listingID
}

# is this a duplicate entity? or do two types of challenges exist?
type Challenge @entity {
    id: ID!                             # The challenge ID
    rewardPool: BigInt!                 # (remaining) Pool of tokens to be distributed to winning voters
    challenger: Bytes!                  # Owner of the challenge
    resolved: Boolean!                  # Indicates if the challenge is resolved (success or fail)
    stake: BigInt!                      # Number of tokens at stake for either party during challenge
    totalTokens: BigInt!                # (remaining number of tokens used in voting by the winning side
    votersClaimed: [Bytes!]!            # If an address is in this array, it has claimed its reward
    data: String!                       # extra data (think ipfs hashes)
    passed: Boolean                     # whether or not it passed. null if not decided yet

    # TODO - relate the poll that is used in this challenge
}

# All solidity, including Token.sol
# User is both a cartographer, and a challenger, or just a token holder doing nothing
type User @entity {
    id: ID!                                                             # eth address

    # Registry.sol
    numApplications: BigInt!    # also stored as mapping public var. Smart contract only counts increases
    totalStaked: BigInt!        # also stored as mapping public var. Smart contract only counts increases
    listings: [Listing!]! @derivedFrom(field: "owner")
    challenges: [Challenge!]! @derivedFrom(field: "challenger")

    # FROM PLCRVoting.sol
    createdPolls: [Poll!]! @derivedFrom(field: "creator")
    votes: [Vote!]! @derivedFrom(field: "user")
    totalVotes: BigInt!   # how many tokens they've allocated to PLCR contract
    lockedVotes: BigInt!

    # Token.sol (FOAM Token)
    foamBalance: BigInt!

    # SignalToken.sol
    signals: [Signal!]! @derivedFrom(field:"owner")                     # ERC-721
}

# TODO - how are these related to voting, and listings?
type Signal @entity {
    id: ID!             # signal token ID
    owner: Bytes!
    cst: Bytes
    nftAddress: Bytes
    geohash: Bytes
    radius: BigInt
}