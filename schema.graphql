## Parameterizer.sol
#type ParamProposal @entity  {
#    id: ID!
#
#    # pollIDs are mapped to these
##    struct ParamProposal {
#    #    uint appExpiry;
#    #    uint challengeID;
#    #    uint deposit;
#    #    string name;
#    #    address owner;
#    #    uint processBy;
#    #    uint value;
##}
#}
#
#type Challenge @entity {
#    id: ID!
#
##    challengeIDs are mapped to these
#
##    struct Challenge {
##        uint rewardPool;        // (remaining) pool of tokens distributed amongst winning voters
##        address challenger;     // owner of Challenge
##        bool resolved;          // indication of if challenge is resolved
##        uint stake;             // number of tokens at risk for either party during challenge
##        uint winningTokens;     // (remaining) amount of tokens used for voting by the winning side
##        mapping(address => bool) tokenClaims;
##    }
#}

# PLCRVoting.sol
# each poll is an instance of a vote on a singal (ERC721 token in the TCR)
type Poll @entity {
    id: ID!
}

# Registry.sol
type Listing @entity {
    id: ID!
    owner: Bytes!
    whitelist: Boolean!
    expiry: BigInt!
    unstakedDeposit: BigInt!
    data: String!


    # prob has a poll and challenge within it
}

# is this a duplicate entity? or do two types of challenges exist?
type Challenge @entity {
    id: ID!                             # The challenge ID
    rewardPool: BigInt!                 # (remaining) Pool of tokens to be distributed to winning voters
    challenger: Bytes!                  # Owner of the challenge
    resolved: Boolean!                  # Indicates if the challenge is resolved (success or fail)
    stake: BigInt!                      # Number of tokens at stake for either party during challenge
    totalTokens: BigInt!                # (remaining number of tokens used in voting by the winning side
    voterClaimed: [Bytes!]!             # If an address is in this array, it has claimed its reward
    # successful: Boolean!

    #    defenders: [Bytes!] # original propser and whoever else joins them (is this possible?, to join?)
}

# All solidity, including Token.sol
# User is both a cartographer, and a challenger, or just a token holder doing nothing
type User @entity {
    id: ID!                                                             # eth address
    foamBalance: BigInt!
    signalBalance: BigInt!                                   # ERC-721
    numApplications: BigInt!    # also stored as mapping public var
    totalStaked: BigInt!        # also stored as mapping public var
    listings: [Listing!]!               @derivedFrom(field: "owner")
    challenges: [Challenge!]!            @derivedFrom(field: "owner")
}
