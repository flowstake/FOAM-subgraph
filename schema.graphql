## Parameterizer.sol
#type ParamProposal @entity  {
#    id: ID!
#
#    # pollIDs are mapped to these
##    struct ParamProposal {
#    #    uint appExpiry;
#    #    uint challengeID;
#    #    uint deposit;
#    #    string name;
#    #    address owner;
#    #    uint processBy;
#    #    uint value;
##}
#}
#
#type Challenge @entity {
#    id: ID!
#
##    challengeIDs are mapped to these
#
##    struct Challenge {
##        uint rewardPool;        // (remaining) pool of tokens distributed amongst winning voters
##        address challenger;     // owner of Challenge
##        bool resolved;          // indication of if challenge is resolved
##        uint stake;             // number of tokens at risk for either party during challenge
##        uint winningTokens;     // (remaining) amount of tokens used for voting by the winning side
##        mapping(address => bool) tokenClaims;
##    }
#}

# PLCRVoting.sol
# each poll is an instance of a vote on a singal (ERC721 token in the TCR)
type Poll @entity {
    id: ID!
}

# Registry.sol
type Listing @entity {
    id: ID!
    owner: Bytes!
    whitelist: Boolean!
    expiry: BigInt!
    unstakedDeposit: BigInt!
    data: String!


    # prob has a poll and challenge within it
}

# is this a duplicate entity? or do two types of challenges exist?
type Challenge @entity {
    id: ID!
    owner: Bytes!
#    winner: Enum! # challeger or defender ???
    challengers: [Bytes!] # anyone who joined in on the challenge
    defenders: [Bytes!] # original propser and whoever else joins them (is this possible?, to join?)
}

# All solidity, including Token.sol
# User is both a cartographer, and a challenger, or just a token holder doing nothing
type User @entity {
    id: ID!                                                             # eth address
    foamBalance: BigInt!
    signalBalance: BigInt!                                   # ERC-721
    numApplications: BigInt!    # also stored as mapping public var
    totalStaked: BigInt!        # also stored as mapping public var
    listings: [Listing!]!               @derivedFrom(field: "owner")
    challenges: [Challenge!]!            @derivedFrom(field: "owner")
}
